# Vorlesung 3

## 1. Stunde

- flaskapp/**main**.py angeschaut
- vorerst bei unicorn geblieben (ist anscheinend auch am verbreitetsetn)
- siehe zeile 40
- asynchrone programmierung mit asgi3
- das entscheidende argument ist "flaskapp:asgi"
- von main gehen wir asgi_app.py und dann zur flaskapp
- get_flask_app() Funktio kommt dann von flask_app.py datei
    - sie leifert das objekt der FLASK_APP zurück (Singleton Pattern)
- jetzt in flask_app.py
    - zeile 48ff.
    - wir haben keine statischen Dateien
    - bei REST:
        - Wir erzeugen blueprint für rest (den basispfad "/rest")
        - ebenfalls registrieren weitere untergeordnete blueprints (hier get und write controller)
          welche durch zwei imports oben in die datei kommen (patient_get & write \_controller)
- in patient_get_controller wurde dann ja z.B. beschrieben, auf welchen pfaden/anfragen er fuktioniert
    - "das controller objekt wurde angereichert und dann von der zentralen "flask_app.py" importiert"
    - siehe zeile 119ff.
        - nun in der mittleren schicht ("Businesslogik")
        - "separation of concerns"
        - "await", wir warten bis das Ergebnis da ist (also hier asgi und nicht wsgi) wsgi ist ein standard für den synchronen fall
- jetzt sind wir in flaskapp/service/patient_read_service.py
    - wieder sehen wir dass es nicht objektorientiert vorgeht sondern funktionen erstellt werden
    -
- Einschub in OR-Mapping:
    - siehe flaskapp/entity/patient.py
    - Klasse ist abgeleitet von Base (flaskapp/entity/base.py) --> hier sieht man auch, dass deklatariv gemapped wird
    - hier werden Properties auf Spalten abgebildet
    - einfache beispiel siehe ab zeile 62ff.
    - sqlalchemy kümmert sich um die ganzen type konvertierungen (or-mapper)
    - nochmal kurz hoch in zeile 56 --> id z.B. mit "auto increment / sequence / generated by id" auf datenbankseite
        - "mapped_column" enthält anforderungen an contraints
        - Identity() weist auf dass es sich um "generated by id" handelt
        - hier id soll bei 1000 beginnen und primary key sein
        - warum 1000? --> platz für testdaten
    - kurzer blick in flaskapp/config/resources/db/postgresql/create.sql
        - man sieht passend zu "patient.py" die SQL-Anweisungen
        - einschub: selbst-generierte typen in postgres mit CREATE TYPEz.B. "geschlecht"
        - was mache ich wenn es diese create type funktion nicht gibt? wenn z.B. nicht in postgresql
          -> varchar mit check contraints
    - wieder zurück in patient.py
        - siehe passend zu create type in DB --> class GEschlecht in zeile 27
        - "Beziehungen sind das Salz in der Suppe"
            - siehe zeile 95ff.
            - "back_populates" -> Rückwärtsverweis
            - inner join zwischen Patient und Adresse (jeder Patient hat eine Adresse und jede Adresse gehört zu einem Patienten)
            - bei 1:n lassen wir inner join weg -> es wird also ein outer join durchgeführt -> enthält also auch Patienten die keine Adresse haben
            - "cascade" --> durch insert von patient wird auch automatisch Adresse und Geschlecht inserted
    - ab ins terminal:
        - docker compose up in flaskapp\.extras\compose\db\postgres
        - http://localhost:8888/
        - siehe tabellen unter Databases/patient/Schemas/patient/tables
    - "checkboxen" also liste von enums, wie macht man das? (beispiel facharzt spalte mit vielen verschiedenen ausprägungen)
        - in postgres z.B. eine liste möglich
        - oder für jede ausprägung eine eigene spalte -> nicht so nice, oft alter table nötig & vile Null Werte in den Spalten
        - 1:n Join Tabelle -> man benötigt oft join
        - Man kann auch einfach einen String mit kommaseparierten Einträgen --> muss man dann aber noch parsen

## 2. Stunde

- genutzte files: "patient_get_controller.py", "patient_repository.py", "patient.py", "patient_read_service.py"
- pfade: flaskapp/rest/..., flaskapp/repository/..., flaskapp/entity/..., flaskapp/service/...

- Spaltentyp json bei fachaerzte
- zwei attribute --> fachaerzte_jason als krücke für die abbildung
- zwei konvertierungen notwending von list von strings (json) in list aus enum UND umgekehrt
    - weil wir in python liste von enums nutzen können aber das in den meisten DB-Systemen nicht geht (untern gehts weiter)
- einschub: oracle hat nur schreibsperren & keine lesesperren --> kann zu lost update kommen
    - postgres hat lesesperren aber defaultmäßig sind die aus
      -> warum? weil deadlocks entstehen können und der durchsatz einfach wichtiger ist als dass man mal ein lost update verhindert
    - oder versionsnummern einführen und vor dem commit einer transaktion immer versionsnummer lesen und hochzählen
        - falls versionsnummer schon eins höher als das was man gelesen hat --> abbrechen weil andere transaktion schneller war
          ---> genau diese "version" ist auch in der "patient.py" in zeile 122 festgelegt
          --> versionsnummer hilft auch beim lesen, falls die version nicht verändert wurde hat sie der client ja schon und es reicht ein 304 (Not Modified) vom Server
- wieder zurück im "patient_get_controller.py"
    - zeile 119ff. "gib mir die daten falls es eine neue version gibt" (bedingter GET-Request)
    - "If-None-Match" Header im GET-Request (ist ein String folgender form bsp. "0")
      -> "gib mir einen patienten, aber nur wenn es eine neuere version als die "0" gibt" --> guter server würde mir 304 antworten wenn schon vorhanden
      -> das ist in zeile 122ff. realisiert
- weiter bei der konvertierung der verschiedenen arten von fachaerzte in "patient_repository.py"
    - siehe zeile 144ff. für eine Richtung
    - Andere Richtung geht dann bei zeile 167ff. weiter
- jetzt in zeile 64ff. -> wir sind jetzt im DB-Layer
    - Ausgangsüberlegung: moderne or-mapper wie sqlalchemy machen grundsätzlich keine joins bei leseanfragen, hibernate z.B. macht das -> aber das ist langsam
    - joinedLoad führt zu einem INNER JOIN weil es so in patient steht
    - in statement steht also "Anweisungsobjekt" und übergebe es an das session objekt (direkt darunter)
- neues beispiel: suche anhand des nachnamens ab zeile 138ff.

### noch allgemein zu Python

- PEPs -> vorschläge, wie man python erweitern kann
    - zwei Arten: eigentliche PEPs die die Programmiersprache um Features ergänzen **&** PEPs die die Infrastruktur ergänzen also nicht konkret die Programmiersprache betreffen
    - Beispiele für zweiteres:
        - Jedes neue Python-Release wird früher schon in einem PEP formuliert
        - oder auch Style-Guides
        - The Zen of Python
    - gibt mittlerweile ein Gremium aus 5 Leuten, die PEPs annehmen oder ablehnen. Vorher Lange Guido van Rossum als wohwollender Diktator
    - Beispiele für ersteres:
        - pip als packet manager
        - list comprehension schon seit 2000 -> cool!
        - logging als bestandteil der programmiersprache
    - stehen auch alle in ReadMe.md